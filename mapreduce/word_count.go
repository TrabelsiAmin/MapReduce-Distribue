package mapreduce

import (
	"strconv"
	"strings"
	"unicode"
)

// The mapping function is called once for each piece of the input.
// In this framework, the value is the contents of the file being
// processed. The return value should be a slice of key/value pairs,
// each represented by a mapreduce.KeyValue.
// A COMPLETER
func MapWordCount(value string) (res []KeyValue) {
	words := strings.FieldsFunc(strings.ToLower(value), func(r rune) bool {
		return !unicode.IsLetter(r)
	})

	counts := make(map[string]int)
	for _, word := range words {
		counts[word]++
	}
	for k, v := range counts {
		res = append(res, KeyValue{Key: k, Value: strconv.Itoa(v)})
	}
	return
}

// The reduce function is called once for each key generated by Map,
// with a list of that key's string value (merged across all
// inputs). The return value should be a single output value for that
// key.
// A COMPLETER
func ReduceWordCount(key string, values []string) string {
	total := 0
	for _, v := range values {
		count, _ := strconv.Atoi(v)
		total += count
	}
	return strconv.Itoa(total)
}
